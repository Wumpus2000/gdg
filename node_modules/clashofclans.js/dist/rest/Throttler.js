"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BatchThrottler_taskLogs;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchThrottler = exports.QueueThrottler = void 0;
const Util_1 = require("../util/Util");
/**
 * Represents a throttler that sleeps for x ms between each request.
 * ```js
 * const throttler = new QueueThrottler(1000 / 10);
 * // 10 requests per second or sleep for 100ms between each request.
 * ```
 */
class QueueThrottler {
    constructor(sleepTime = 100) {
        this.promises = [];
        this.sleepTime = sleepTime;
    }
    get remaining() {
        return this.promises.length;
    }
    async throttle() {
        if (this.lastRun) {
            const difference = Date.now() - this.lastRun;
            const needToSleep = this.sleepTime - difference;
            if (needToSleep > 0)
                await Util_1.Util.delay(needToSleep);
        }
        this.lastRun = Date.now();
        return this.shift();
    }
    wait() {
        const next = this.promises.length ? this.promises[this.promises.length - 1].promise : Promise.resolve();
        let resolve;
        const promise = new Promise((res) => {
            resolve = res;
        });
        this.promises.push({ resolve: resolve, promise });
        return next;
    }
    shift() {
        const deferred = this.promises.shift();
        if (typeof deferred !== 'undefined')
            deferred.resolve();
    }
}
exports.QueueThrottler = QueueThrottler;
/**
 * Represents a throttler that allows x requests per second before sleeping until the next second.
 * ```js
 * const throttler = new BatchThrottler(30);
 * // 30 requests every second.
 * ```
 */
class BatchThrottler {
    constructor(rateLimit = 10) {
        _BatchThrottler_taskLogs.set(this, []); // eslint-disable-line
        this.rateLimit = rateLimit;
    }
    async wait() {
        return Promise.resolve();
    }
    async throttle() {
        while (true) { // eslint-disable-line
            const now = Date.now();
            while (__classPrivateFieldGet(this, _BatchThrottler_taskLogs, "f").length) {
                if (now - __classPrivateFieldGet(this, _BatchThrottler_taskLogs, "f")[0] > 1000) {
                    __classPrivateFieldGet(this, _BatchThrottler_taskLogs, "f").shift();
                }
                else {
                    break;
                }
            }
            if (__classPrivateFieldGet(this, _BatchThrottler_taskLogs, "f").length < this.rateLimit)
                break;
            await Util_1.Util.delay(1000);
        }
        __classPrivateFieldGet(this, _BatchThrottler_taskLogs, "f").push(Date.now());
    }
}
exports.BatchThrottler = BatchThrottler;
_BatchThrottler_taskLogs = new WeakMap();
